# Why ROOK

I'm starting a programming journey with a new language I am developing called ROOK. In this post, I'll share my motivations for creating it and the goals I aim to achieve with this endeavor.

## Goals:

- **Modern Approach:** I'm crafting a language that embraces modern ergonomics and practices, shedding any legacy baggage. It's about moving forward, not being tethered to the past.
- **Cross-Platform Focus:** ROOK targets [WASM](https://webassembly.org/) and [WASI](https://wasi.dev/), aiming for seamless cross-platform functionality.
- **Clarity:** The language is designed to be expressive and transparent. I believe in showing, not hiding - the user should see and understand everything clearly.
- **Minimal Syntax / Features:** ROOK follows a "one way" approach to syntax. Hence the name - **R**eally **O**nly **O**ne **K**eyword. This isn't about overwhelming options; it's about streamlined, clear-cut coding. I'm focusing on fewer features, but each will be robust and powerful. It's about quality, not quantity.
- **Defensive Programming:** The language encourages a proactive approach to writing secure and reliable code.
- **Learning from the Best:** Inspiration is drawn from languages like [Zig](https://ziglang.org/), [Go](https://golang.org/), [Odin](https://odin-lang.org/), [Jai](https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md), and [Hare](https://harelang.org/) - all pioneers in modern language design.
- **Robust Developer Tools:** I'm integrating essential tools like LSP, built-in formatter, in-language compilation scripts (a nod to Zig), and integrated testing and examples. It's all about making the developer's life easier.

## Non-Goals:

- This isn't about replacing C/C++. It's about offering something different.
- Stepping away from C-like syntax to explore new frontiers.
- ROOK is not about embracing Object-Oriented Programming (OOP).
- I'm not trying to pack it with endless features. It's about doing more with less.
- I'm avoiding complex abstractions and convoluted build systems. 

## Personal Goals:

- This is a personal challenge. I'm rethinking how I program and exploring my ideal syntax.
- Delving into compilers and language design, an area I deeply cherish, harks back to an unforgettable university class. The professor's expertise truly ignited my passion, and the crowning achievement was developing a working compiler by the end of the course, an experience I found profoundly rewarding.
- Ironically, through this journey, I'm sharpening my skills in C(99) and low-level programming.

With ROOK, I'm not just creating a language. I'm building a tool that aligns with how I believe programming should be: straightforward, effective, and pragmatic. It's a reflection of my programming philosophy, and I'm excited to share this journey with you.


<!---# 

Original text draft

Why ROOK

Bellow are written what I am trying to achive with this language and why I am making it.

Goals:
- Modern language that has modern ergonomics, practices and no legacy system or mindset
- Cross-platform targeting WASM and WASI
- Expressive and easy to read, nothing should be hidden from user
- Only "one way" to **SYNTACTICLY** achieve something (That why the name **R**eally **O**nly **O**ne **K**eyword language)
- Minimalistic language features but strong ones
- Defensive programming
- Taking inspiration from other modern languages that want to achieve similiar things:
    1. Zig
    2. Go
    3. Odin
    4. Jai
    5. Hare
- Good developer tools:
    1. LSP
    2. Formatter (build into toolchain)
    3. Compalation scripts are done in language itself (same as Zig), no need to learn something new
    4. Tests are part of language
    5. Examples


Non-Goals:
- Replace C/C++ 
- Be Object Oriented (OOP)
- Have tons of features
- Have similiar sintax that C 
- Having huge abstractions and complex build systems 


Personal Goals
- Trying to challenge (myself) to think how I program and how would I like to write syntax
- Learning about compilers and programming languages
- Ironicly but along the way getting better in C(99) and low level programing

--->

